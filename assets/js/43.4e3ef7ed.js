(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{247:function(t,e,a){"use strict";a.r(e);var s=a(6),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[t._v("#")]),t._v(" Status")]),t._v(" "),a("p",[t._v("Not all language features are equally viable to implement on top of WebAssembly's current capabilities, and while AssemblyScript is already useful today, there is also still a lot to do. Keep in mind that WebAssembly is an evolving technology, and so is AssemblyScript.")]),t._v(" "),a("h2",{attrs:{id:"philosophy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#philosophy"}},[t._v("#")]),t._v(" Philosophy")]),t._v(" "),a("p",[t._v("The original idea which made AssemblyScript attractive is that it aims to be a thin and efficient layer on top of WebAssembly with a familiar syntax, ultimately producing lean and mean binaries. This idea is composed of two components, however, that are sometimes orthogonal: "),a("strong",[t._v("Lean and mean")]),t._v(" implies that we have to stay close to WebAssembly's capabilities, i.e. not going too far already where implementations of certain language features would be inefficient or increase binary size disproportionately, while a "),a("strong",[t._v("familiar syntax")]),t._v(" naturally begs for supporting more of the original language right now.")]),t._v(" "),a("p",[t._v("As such, while AssemblyScript wants to stay as close as possible to being a language that feels very familiar with JavaScript and TypeScript developers, and aims to preserve compatiblity with existing tooling, it ultimately is a language compiling to WebAssembly and will prioritize language features that allow developers to write fast and small WebAssembly modules on top of the features that WebAssembly already provides.")]),t._v(" "),a("h2",{attrs:{id:"webassembly-features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webassembly-features"}},[t._v("#")]),t._v(" WebAssembly features")]),t._v(" "),a("p",[t._v("Some crucial language features rely on "),a("a",{attrs:{href:"https://github.com/WebAssembly/proposals",target:"_blank",rel:"noopener noreferrer"}},[t._v("future WebAssembly functionality"),a("OutboundLink")],1),t._v(" to be efficient. The following table aims to give an overview from a WebAssembly perspective:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("WebAssembly spec")]),t._v(" "),a("th",[t._v("Engines")]),t._v(" "),a("th",[t._v("AssemblyScript (flag)")]),t._v(" "),a("th",[t._v("What's the plan?")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("‚úîÔ∏è "),a("strong",[t._v("Finished proposal")])]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Import/export mutable globals")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi"),t._v(" "),a("Sa"),t._v(" "),a("No"),t._v(" "),a("Wa")],1),t._v(" "),a("td",[t._v("‚úîÔ∏è")]),t._v(" "),a("td",[t._v("Global variable interop")])]),t._v(" "),a("tr",[a("td",[t._v("BigInt integration")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi"),t._v(" "),a("Wa"),a("sup",[t._v("1")])],1),t._v(" "),a("td",[t._v("‚úîÔ∏è")]),t._v(" "),a("td",[t._v("64-bit integer interop")])]),t._v(" "),a("tr",[a("td",[t._v("Non-trapping F2I")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi"),t._v(" "),a("No"),t._v(" "),a("Wa")],1),t._v(" "),a("td",[t._v("‚è≥")]),t._v(" "),a("td",[t._v("Checked and unchecked casts")])]),t._v(" "),a("tr",[a("td",[t._v("Sign-extension")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi"),t._v(" "),a("No"),t._v(" "),a("Wa")],1),t._v(" "),a("td",[t._v("‚è≥ "),a("code",[t._v("sign-extension")])]),t._v(" "),a("td",[t._v("Efficient small integer casts")])]),t._v(" "),a("tr",[a("td",[t._v("Multi-value")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi"),t._v(" "),a("Sa"),t._v(" "),a("Wa")],1),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Tuple return values?")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üèÅ "),a("strong",[t._v("Standardize the feature")])]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Reference Types")]),t._v(" "),a("td",[a("Fi"),t._v(" "),a("Wa")],1),t._v(" "),a("td",[t._v("‚è≥ "),a("code",[t._v("reference-types")])]),t._v(" "),a("td",[t._v("Prerequisite for garbage collection")])]),t._v(" "),a("tr",[a("td",[t._v("Bulk memory")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi"),t._v(" "),a("Wa")],1),t._v(" "),a("td",[t._v("‚è≥ "),a("code",[t._v("bulk-memory")])]),t._v(" "),a("td",[t._v("Replace "),a("code",[t._v("memcpy")]),t._v(", "),a("code",[t._v("memset")])])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üî® "),a("strong",[t._v("Implementation phase")])]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Tail call")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Fixed-width SIMD")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("‚è≥ "),a("code",[t._v("simd")])]),t._v(" "),a("td",[t._v("Expose as built-ins; Auto-vectorize?")])]),t._v(" "),a("tr",[a("td",[t._v("Multiple memories")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Custom annotations")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üìñ "),a("strong",[t._v("Spec text available")])]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Threads")]),t._v(" "),a("td",[a("Ch"),t._v(" "),a("Fi")],1),t._v(" "),a("td",[t._v("‚è≥ "),a("code",[t._v("threads")])]),t._v(" "),a("td",[t._v("Expose as built-ins; WebWorker?")])]),t._v(" "),a("tr",[a("td",[t._v("ESM integration")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Natural web interop")])]),t._v(" "),a("tr",[a("td",[t._v("Exception handling")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("‚è≥ "),a("code",[t._v("exception-handling")])]),t._v(" "),a("td",[t._v("Implement exceptions")])]),t._v(" "),a("tr",[a("td",[t._v("Function references")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Implement closures")])]),t._v(" "),a("tr",[a("td",[t._v("Memory64")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("‚è≥")]),t._v(" "),a("td",[t._v("Provide a Wasm64 target")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üí° "),a("strong",[t._v("Feature proposal")])]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Type Imports")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Web interop?")])]),t._v(" "),a("tr",[a("td",[t._v("Garbage collection")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Reuse host GC; Share objects?")])]),t._v(" "),a("tr",[a("td",[t._v("Interface Types")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Non-web interop?")])]),t._v(" "),a("tr",[a("td",[t._v("Feature detection")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Extended name section")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("‚è≥")]),t._v(" "),a("td",[t._v("Debug names for locals etc.")])]),t._v(" "),a("tr",[a("td",[t._v("Flexible vectors")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Expose as built-ins")])]),t._v(" "),a("tr",[a("td",[t._v("Call Tags")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Module Linking")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Linking pre-compiled modules")])]),t._v(" "),a("tr",[a("td",[t._v("Branch hinting")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[a("code",[t._v("likely(x)")]),t._v(", "),a("code",[t._v("unlikely(x)")]),t._v("?")])])])]),t._v(" "),a("Ch"),t._v(" Chrome ¬†\n"),a("Fi"),t._v(" Firefox ¬†\n"),a("Sa"),t._v(" Safari ¬†\n"),a("No"),t._v(" Node.js ¬†\n"),a("Wa"),t._v(" Wasmtime ("),a("sup",[t._v("1")]),t._v(" native i64 support)\n"),a("h2",{attrs:{id:"language-features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#language-features"}},[t._v("#")]),t._v(" Language features")]),t._v(" "),a("p",[t._v("As such, certain higher-level language features still have their limitations or are not yet available. From a language perspective:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Feature")]),t._v(" "),a("th",[t._v("What to expect?")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("üê§ "),a("strong",[t._v("Functional")])]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#bootstrap"}},[t._v("Bootstrap")])]),t._v(" "),a("td",[t._v("The compiler can compile itself to WebAssembly, passing the test suite.")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#classes-and-interfaces"}},[t._v("Classes and interfaces")])]),t._v(" "),a("td",[t._v("Largely implemented in linear memory. Some caveats. (needs GC ü¶Ñ)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#standard-library"}},[t._v("Standard library")])]),t._v(" "),a("td",[t._v("Largely implemented in linear memory. Some caveats.")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#generics"}},[t._v("Generics")])]),t._v(" "),a("td",[t._v("Monomorphized templates for now. (maybe post-MVP GC ü¶Ñ)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#garbage-collection"}},[t._v("Garbage collection")])]),t._v(" "),a("td",[t._v("Implemented in linear memory for now. (needs GC ü¶Ñ)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#interop-with-js"}},[t._v("Interop with JS")])]),t._v(" "),a("td",[t._v("Enabled by the loader package. (needs Type imports / Interface Types ü¶Ñ)")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üê£ "),a("strong",[t._v("Limited")])]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#union-types"}},[t._v("Union types")])]),t._v(" "),a("td",[t._v("Nullable class types only. Can use generics with static type checks instead. (No proposal so far)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#symbols"}},[t._v("Symbols")])]),t._v(" "),a("td",[t._v("Implemented, but no deep compiler integration yet.")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#json"}},[t._v("JSON")])]),t._v(" "),a("td",[t._v("Third-party library available.")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#regexp"}},[t._v("RegExp")])]),t._v(" "),a("td",[t._v("Third-party library available.")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("ü•ö "),a("strong",[t._v("Not implemented")])]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#closures"}},[t._v("Closures")])]),t._v(" "),a("td",[t._v("Perhaps implement in linear memory. (needs Function references ü¶Ñ)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#iterators"}},[t._v("Iterators")])]),t._v(" "),a("td",[t._v("Not implemented yet. Depends on symbols.")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#rest-parameters"}},[t._v("Rest parameters")])]),t._v(" "),a("td",[t._v("Perhaps implement in linear memory. (No proposal so far)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#exceptions"}},[t._v("Exceptions")])]),t._v(" "),a("td",[t._v("Throwing currently aborts the program. (needs Exception handling ü¶Ñ)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#promises"}},[t._v("Promises")])]),t._v(" "),a("td",[t._v("There is no concept of async/await yet due to the lack of an event loop. (No proposal so far)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#bigint"}},[t._v("BigInt")])]),t._v(" "),a("td",[t._v("There are no BigInts yet, but there are i64s.")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üï≥Ô∏è "),a("strong",[t._v("Not supported")])]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#dynamicness"}},[t._v("Dynamicness")])]),t._v(" "),a("td",[t._v("AssemblyScript avoids overly dynamic JavaScript features by design.")])])])]),t._v(" "),a("h3",{attrs:{id:"bootstrap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap"}},[t._v("#")]),t._v(" Bootstrap")]),t._v(" "),a("p",[t._v('The first release able to bootstrap itself and pass the test suite is v0.18, released in January 2021. Note that the compiler is not technically "self hosted" in WebAssembly still, as it currently uses a JavaScript frontend for I/O and links to Binaryen (C++ with Emscripten), which also requires some JavaScript glue code. As such, to make the compiler work in a WebAssembly-only engine like Wasmtime, the next steps would be to work towards a WebAssembly-only build of Binaryen, and replace the I/O parts provided by '),a("code",[t._v("asc")]),t._v(" with WASI.")]),t._v(" "),a("h3",{attrs:{id:"classes-and-interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#classes-and-interfaces"}},[t._v("#")]),t._v(" Classes and interfaces")]),t._v(" "),a("p",[t._v("These mostly work, with a a few caveats.")]),t._v(" "),a("ul",[a("li",[t._v("Access modifiers like "),a("code",[t._v("private")]),t._v(" and "),a("code",[t._v("protected")]),t._v(" are not currently enforced. Likely to be enforced in the future.")]),t._v(" "),a("li",[t._v("Interface fields must be implemented as getters and setters. Likely to be lifted in the future.")]),t._v(" "),a("li",[t._v("Note that WebAssembly doesn't magically neglect the runtime cost of making extensive use of managed classes, so there are often faster alternatives.")])]),t._v(" "),a("h3",{attrs:{id:"standard-library"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#standard-library"}},[t._v("#")]),t._v(" Standard library")]),t._v(" "),a("p",[t._v("Some "),a("RouterLink",{attrs:{to:"/stdlib/globals.html"}},[t._v("standard library APIs")]),t._v(" function a little different than in JavaScript to account for differences introduced by static typing or missing WebAssembly features. We are also maintaining a "),a("a",{attrs:{href:"https://github.com/AssemblyScript/assemblyscript/wiki/Status-and-Roadmap",target:"_blank",rel:"noopener noreferrer"}},[t._v("separate status document"),a("OutboundLink")],1),t._v(" specific to the standard library.")],1),t._v(" "),a("h3",{attrs:{id:"generics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generics"}},[t._v("#")]),t._v(" Generics")]),t._v(" "),a("p",[t._v("AssemblyScript compiles generics to one concrete method or function per set of unique contextual type arguments, also known as "),a("a",{attrs:{href:"https://en.wiktionary.org/wiki/monomorphisation",target:"_blank",rel:"noopener noreferrer"}},[t._v("monomorphisation"),a("OutboundLink")],1),t._v(". Implications are that a module only includes and exports concrete functions for sets of type arguments actually used and that concrete functions can be shortcutted with "),a("RouterLink",{attrs:{to:"/environment.html#static-type-checks"}},[t._v("static type checks")]),t._v(" at compile time, which turned out to be quite useful.")],1),t._v(" "),a("ul",[a("li",[t._v("The compiler does not currently enforce "),a("code",[t._v("extends Y")]),t._v(" clauses on type parameters. Likely to be enforced in the future.")]),t._v(" "),a("li",[t._v("WebAssembly GC ü¶Ñ may introduce more sophisticated mechanisms like reified generics, potentially post-MVP.")]),t._v(" "),a("li",[t._v("Concrete functions compiling to the exact same code are de-duplicated during optimization.")])]),t._v(" "),a("h3",{attrs:{id:"garbage-collection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#garbage-collection"}},[t._v("#")]),t._v(" Garbage collection")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/garbage-collection.html"}},[t._v("Garbage collection")]),t._v(" is currently implemented in linear memory, independent from the host, and is best paired with "),a("RouterLink",{attrs:{to:"/loader.html"}},[t._v("the loader")]),t._v(" for interop.")],1),t._v(" "),a("h3",{attrs:{id:"interop-with-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interop-with-js"}},[t._v("#")]),t._v(" Interop with JS")]),t._v(" "),a("p",[t._v("WebAssembly only understands numeric values as of today and cannot easily exchange objects with JavaScript. Hence, when an object is returned from WebAssembly to JavaScript, what the caller passes and the callee receives is a pointer to the object in linear memory. Note that WebAssembly does not know what to do with JavaScript objects passed to it, as the VM will implicitly convert the object to a number when it crosses the boundary, which is typically not what you want.")]),t._v(" "),a("p",[t._v("For example, to pass a string to a WebAssembly export, one first has to allocate the string in the WebAssembly module's linear memory, and then pass the resulting pointer to the WebAssembly export. The same is true for arrays and other objects.")]),t._v(" "),a("p",[t._v("For now, "),a("RouterLink",{attrs:{to:"/loader.html"}},[t._v("the loader")]),t._v(" provides the utility necessary to translate between objects in linear memory and JavaScript objects (e.g. with "),a("code",[t._v("__newString")]),t._v(" and "),a("code",[t._v("__getString")]),t._v("), and our hopes are on Type Imports ü¶Ñ, Interface Types ü¶Ñ and perhaps Garbage collection ü¶Ñ to make interop more convenient eventually.")],1),t._v(" "),a("p",[t._v("See also: "),a("RouterLink",{attrs:{to:"/frequently-asked-questions.html#will-interop-between-assemblyscript-and-javascript-become-better"}},[t._v("Will interop between AssemblyScript and JavaScript become better?")])],1),t._v(" "),a("h3",{attrs:{id:"union-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#union-types"}},[t._v("#")]),t._v(" Union types")]),t._v(" "),a("p",[t._v("WebAssembly cannot efficiently represent locals or globals of dynamic types, so union types are not supported in AssemblyScript. One can however take advantage of the fact that AssemblyScript is a static compiler, with monomorphized generics and "),a("RouterLink",{attrs:{to:"/environment.html#static-type-checks"}},[t._v("static type checks")]),t._v(", to achieve a similar effect:")],1),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addOrConcat")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// concats if a string, otherwise adds")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addOrSomethingElse")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isString")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"something else"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// eliminated if T is not a string")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// eliminated if T is a string")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Another effect of the above is that AssemblyScript does not have an "),a("code",[t._v("any")]),t._v(" type or "),a("code",[t._v("undefined")]),t._v(" value.")]),t._v(" "),a("h3",{attrs:{id:"symbols"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symbols"}},[t._v("#")]),t._v(" Symbols")]),t._v(" "),a("p",[t._v("The standard library implements "),a("RouterLink",{attrs:{to:"/stdlib/symbol.html"}},[a("code",[t._v("Symbol")])]),t._v(", and it is possible to work with and create new symbols, but there is no deep compiler integration like registration of "),a("code",[t._v("Symbol.iterator")]),t._v(" etc. yet.")],1),t._v(" "),a("h3",{attrs:{id:"json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json"}},[t._v("#")]),t._v(" JSON")]),t._v(" "),a("p",[t._v("JSON integration in the compiler itself is still an open question due to its untyped nature. May require a mix of reflection and schema-specific code generation for natural integration.")]),t._v(" "),a("p",[t._v("Solutions being developed by the community:")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/nearprotocol/assemblyscript-json",target:"_blank",rel:"noopener noreferrer"}},[t._v("nearprotocol/assemblyscript-json"),a("OutboundLink")],1)])]),t._v(" "),a("h3",{attrs:{id:"regexp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regexp"}},[t._v("#")]),t._v(" RegExp")]),t._v(" "),a("p",[t._v("Regular expressions have been on our todo list for quite a while. It's mostly that a good implementation becomes complicated pretty quickly with special Unicode cases, exponential behavior and so on. Also, an ideal RegExp implementation would be compatible with the ECMAScript specification, reasonably fast and integrate deeply with the compiler, so RegExp literals can be pre-compiled (to WebAssembly code or an intermediate bytecode), making it unnecessary most of the time to ship the entire engine with a module.")]),t._v(" "),a("p",[t._v("Solutions being developed by the community:")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/ColinEberhardt/assemblyscript-regex",target:"_blank",rel:"noopener noreferrer"}},[t._v("ColinEberhardt/assemblyscript-regex"),a("OutboundLink")],1)])]),t._v(" "),a("h3",{attrs:{id:"closures"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#closures"}},[t._v("#")]),t._v(" Closures")]),t._v(" "),a("p",[t._v("Closures (functions with a captured environment) are not yet supported and we are waiting for the Function References ü¶Ñ and Garbage collection ü¶Ñ (captured environments are GC'ed) proposals to land. However, since this is a crucial language feature, we may end up with a filler implementation using linear memory. Not available yet, though.")]),t._v(" "),a("p",[t._v("In the meantime we recommend to restructure code so closures are not necessary, i.e. instead of writing")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("computeSum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fails")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("restructure to")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" sum"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// becomes a WebAssembly Global")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("computeSum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// works")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("or to")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("computeSum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// works")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"iterators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iterators"}},[t._v("#")]),t._v(" Iterators")]),t._v(" "),a("p",[t._v("It has not been attempted to implement iterators due to uncertainty how efficient iterators will be using frequent dynamic allocation. Also requires symbols for deep integration. Therefore "),a("code",[t._v("for ... of")]),t._v(" loops are not currently supported. To work around the limitation of not having iterators, otherwise non-functional standard library APIs return an array for now:")]),t._v(" "),a("h4",{attrs:{id:"map-k-v"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-k-v"}},[t._v("#")]),t._v(" Map<K,V>")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("keys")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("K")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])])]),t._v(" "),a("li",[a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("values")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("V")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"set-t"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-t"}},[t._v("#")]),t._v(" Set<T>")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("values")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"rest-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rest-parameters"}},[t._v("#")]),t._v(" Rest parameters")]),t._v(" "),a("p",[t._v("It has not yet been attempted to implement variadic functions due to uncertainty how efficient it will be without random stack access. The risk is that doing dynamic allocations instead may introduce an unfortunate hidden cost to function calls.")]),t._v(" "),a("p",[t._v("In the meantime, optional function arguments, which do not have such a hidden cost, may be able to help:")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleGiven")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exceptions"}},[t._v("#")]),t._v(" Exceptions")]),t._v(" "),a("p",[t._v("Exceptions are not yet supported and we are waiting for the Exception handling ü¶Ñ proposal to land. It is not yet feasible to implement exceptions without the help of the proposal as throwing and catching an exception requires stack unwinding, so the following will currently crash the program with a call to "),a("code",[t._v('abort("message", ...)')]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("doThrow")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"message"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("In the meantime we recommend to do as they did in the olden days and return an error code or "),a("code",[t._v("null")]),t._v(" to indicate an exception.")]),t._v(" "),a("h3",{attrs:{id:"promises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promises"}},[t._v("#")]),t._v(" Promises")]),t._v(" "),a("p",[t._v("The concept of async execution requires an underlying concept of an event loop, which browsers and Node.js have but WebAssembly does not. In the meantime, it is recommended to stick to synchronous code within WebAssembly or call back into WebAssembly when an external async operation completes.")]),t._v(" "),a("h3",{attrs:{id:"bigint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bigint"}},[t._v("#")]),t._v(" BigInt")]),t._v(" "),a("p",[t._v("We have favored the use of WebAssembly's native 64-bit integers over "),a("code",[t._v("BigInt")]),t._v("s and their "),a("code",[t._v("INTn")]),t._v(" notation so far, since "),a("code",[t._v("BigInt")]),t._v("s can represent values > 64-bits and as such would have to be implemented as less-efficient heap allocated objects. There are certain use cases relying on representing more than 64-bits, of course, but we still have to figure out how to support both types without introducing conflicts.")]),t._v(" "),a("h3",{attrs:{id:"dynamicness"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dynamicness"}},[t._v("#")]),t._v(" Dynamicness")]),t._v(" "),a("p",[t._v("AssemblyScript intentionally avoids very dynamic JavaScript features that cannot be compiled efficiently, like for example:")]),t._v(" "),a("ul",[a("li",[t._v("Assigning any value to any variable.")]),t._v(" "),a("li",[t._v("Compare values of incompatible types.")]),t._v(" "),a("li",[t._v("Implicitly convert from a non-string to a string without using "),a("code",[t._v("x.toString()")]),t._v(".")]),t._v(" "),a("li",[t._v("Assign a new property, that has not been statically declared, to a class or object.")]),t._v(" "),a("li",[t._v("Assign a class to a variable (e.g. "),a("code",[t._v("var clazz = MyClass")]),t._v(") since classes are static constructs without a runtime representation.")]),t._v(" "),a("li",[t._v("Patch class "),a("code",[t._v(".prototype")]),t._v("s since there are none.")]),t._v(" "),a("li",[t._v("Access "),a("code",[t._v("arguments")]),t._v(" to dynamically obtain function arguments.")]),t._v(" "),a("li",[t._v("Dynamically obtain the name of a function at runtime or otherwise use reflection.")])]),t._v(" "),a("p",[t._v("Some of these restrictions, like implicit conversion to strings when concatenating with a string, may be lifted in the future, while others, like prototypes, may never be viable in ahead-of-time compilation. For instance, some features would work in an interpreter and may become efficient with a JIT compiler, yet going down that rabbit hole runs counter to WebAssembly's, and by definition AssemblyScript's, goals.")]),t._v(" "),a("h2",{attrs:{id:"tooling-features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tooling-features"}},[t._v("#")]),t._v(" Tooling features")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Feature")]),t._v(" "),a("th",[t._v("What to expect?")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("üê§ "),a("strong",[t._v("Functional")])]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#debugging"}},[t._v("Debugging")])]),t._v(" "),a("td",[t._v("Support for debug information and source maps. (needs DWARF support)")])]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#testing"}},[t._v("Testing")])]),t._v(" "),a("td",[t._v("With assertions. Third-party library available.")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("üê£ "),a("strong",[t._v("Limited")])]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#linting"}},[t._v("Linting")])]),t._v(" "),a("td",[t._v("Re-used TypeScript tooling. Third-party tooling available.")])])])]),t._v(" "),a("h3",{attrs:{id:"debugging"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#debugging"}},[t._v("#")]),t._v(" Debugging")]),t._v(" "),a("p",[t._v("Debugging of AssemblyScript modules is not as convenient as it should be, but "),a("RouterLink",{attrs:{to:"/debugging.html"}},[t._v("possible with debug information and accompanying source maps")]),t._v(". For a better debugging experience, we may eventually want to integrate with the "),a("a",{attrs:{href:"http://dwarfstd.org",target:"_blank",rel:"noopener noreferrer"}},[t._v("DWARF"),a("OutboundLink")],1),t._v(" format used by for example LLVM, ideally through Binaryen.")],1),t._v(" "),a("h3",{attrs:{id:"testing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testing"}},[t._v("#")]),t._v(" Testing")]),t._v(" "),a("p",[t._v("The standard library provides the "),a("RouterLink",{attrs:{to:"/environment.html#utility"}},[a("code",[t._v("assert")])]),t._v(" built-in, which does not decide on a particular flavor of testing, yet is often sufficient to write basic tests.")],1),t._v(" "),a("p",[t._v("Solutions being developed by the community:")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/jtenner/as-pect",target:"_blank",rel:"noopener noreferrer"}},[t._v("jtenner/as-pect"),a("OutboundLink")],1)])]),t._v(" "),a("h3",{attrs:{id:"linting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linting"}},[t._v("#")]),t._v(" Linting")]),t._v(" "),a("p",[t._v("AssemblyScript piggy-backs on top of TypeScript's excellent infrastructure currently, making it trivial to get started, but could need more sophisticated checking (as one types) for where code is valid TypeScript but not valid AssemblyScript or vice-versa with "),a("code",[t._v("// @ts-ignore")]),t._v(". It is still an open question whether a custom language server is needed (potentially with a separate file extension), or if a plugin on top of existing TypeScript tooling would be an equally viable option. The latter would imply having to reinvent fewer wheels, like code navigation and refactoring etc., while the former may feel more polished once all the wheels have been reinvented.")]),t._v(" "),a("p",[t._v("Solutions being developed by the community:")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/Shopify/asls",target:"_blank",rel:"noopener noreferrer"}},[t._v("Shopify/asls"),a("OutboundLink")],1)])])],1)}),[],!1,null,null,null);e.default=n.exports}}]);